"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var EventEmitter = require('events');

var fs = require('fs');

var _require = require('path'),
    resolve = _require.resolve;

var pWaitFor = require('p-wait-for');

var combineErrors = require('combine-errors');

var debug = require('debug')('bree');

var isSANB = require('is-string-and-not-blank');

var isValidPath = require('is-valid-path');

var later = require('@breejs/later');

var threads = require('bthreads');

var _require2 = require('safe-timers'),
    setTimeout = _require2.setTimeout,
    setInterval = _require2.setInterval;

var _require3 = require('./job-utils'),
    isSchedule = _require3.isSchedule,
    getName = _require3.getName,
    getHumanToMs = _require3.getHumanToMs,
    parseValue = _require3.parseValue,
    getJobNames = _require3.getJobNames;

var buildJob = require('./job-builder');

var validateJob = require('./job-validator'); // bthreads requires us to do this for web workers (see bthreads docs for insight)


threads.Buffer = Buffer; // instead of `threads.browser` checks below, we previously used this boolean
// const hasFsStatSync = typeof fs === 'object' && typeof fs.statSync === 'function';

var Bree = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2.default)(Bree, _EventEmitter);

  var _super = _createSuper(Bree);

  function Bree(config) {
    var _this;

    (0, _classCallCheck2.default)(this, Bree);
    _this = _super.call(this);
    _this.config = _objectSpread({
      // we recommend using Cabin for logging
      // <https://cabinjs.com>
      logger: console,
      // set this to `false` to prevent requiring a root directory of jobs
      // (e.g. if your jobs are not all in one directory)
      root: threads.browser ?
      /* istanbul ignore next */
      threads.resolve('jobs') : resolve('jobs'),
      // default timeout for jobs
      // (set this to `false` if you do not wish for a default timeout to be set)
      timeout: 0,
      // default interval for jobs
      // (set this to `0` for no interval, and > 0 for a default interval to be set)
      interval: 0,
      // this is an Array of your job definitions (see README for examples)
      jobs: [],
      // <https://breejs.github.io/later/parsers.html#cron>
      // (can be overridden on a job basis with same prop name)
      hasSeconds: false,
      // <https://github.com/Airfooox/cron-validate>
      cronValidate: {},
      // if you set a value > 0 here, then it will terminate workers after this time (ms)
      closeWorkerAfterMs: 0,
      // could also be mjs if desired
      // (this is the default extension if you just specify a job's name without ".js" or ".mjs")
      defaultExtension: 'js',
      // default worker options to pass to ~`new Worker`~ `new threads.Worker`
      // (can be overridden on a per job basis)
      // <https://nodejs.org/api/worker_threads.html#worker_threads_new_worker_filename_options>
      worker: {},
      // custom handler to execute when error events are emmited by the workers or when they exit
      // with non-zero code
      // pass in a callback function with following signature: `(error, workerMetadata) => { // custom handling here }`
      errorHandler: null,
      //
      // if you set this to `true`, then a second arg is passed to log output
      // and it will be an Object with `{ worker: Object }` set, for example:
      // (see the documentation at <https://nodejs.org/api/worker_threads.html> for more insight)
      //
      // logger.info('...', {
      //   worker: {
      //     isMainThread: Boolean
      //     resourceLimits: Object,
      //     threadId: String
      //   }
      // });
      //
      outputWorkerMetadata: false
    }, config); //
    // if `hasSeconds` is `true` then ensure that
    // `cronValidate` object has `override` object with `useSeconds` set to `true`
    // <https://github.com/breejs/bree/issues/7>
    //

    if (_this.config.hasSeconds) _this.config.cronValidate = _objectSpread(_objectSpread({}, _this.config.cronValidate), {}, {
      preset: _this.config.cronValidate && _this.config.cronValidate.preset ? _this.config.cronValidate.preset : 'default',
      override: _objectSpread(_objectSpread({}, _this.config.cronValidate && _this.config.cronValidate.override ? _this.config.cronValidate.override : {}), {}, {
        useSeconds: true
      })
    });
    debug('config', _this.config);
    _this.closeWorkerAfterMs = {};
    _this.workers = {};
    _this.timeouts = {};
    _this.intervals = {};
    _this.isSchedule = isSchedule;
    _this.getWorkerMetadata = _this.getWorkerMetadata.bind((0, _assertThisInitialized2.default)(_this));
    _this.run = _this.run.bind((0, _assertThisInitialized2.default)(_this));
    _this.start = _this.start.bind((0, _assertThisInitialized2.default)(_this));
    _this.stop = _this.stop.bind((0, _assertThisInitialized2.default)(_this));
    _this.add = _this.add.bind((0, _assertThisInitialized2.default)(_this));
    _this.remove = _this.remove.bind((0, _assertThisInitialized2.default)(_this));
    _this.validateJob = validateJob;
    _this.getName = getName;
    _this.getHumanToMs = getHumanToMs;
    _this.parseValue = parseValue; // validate root (sync check)

    if (isSANB(_this.config.root)) {
      /* istanbul ignore next */
      if (!threads.browser && isValidPath(_this.config.root)) {
        var stats = fs.statSync(_this.config.root);
        if (!stats.isDirectory()) throw new Error("Root directory of ".concat(_this.config.root, " does not exist"));
      }
    } // validate timeout


    _this.config.timeout = _this.parseValue(_this.config.timeout);
    debug('timeout', _this.config.timeout); // validate interval

    _this.config.interval = _this.parseValue(_this.config.interval);
    debug('interval', _this.config.interval); //
    // if `this.config.jobs` is an empty array
    // then we should try to load `jobs/index.js`
    //

    if (_this.config.root && (!Array.isArray(_this.config.jobs) || _this.config.jobs.length === 0)) {
      try {
        _this.config.jobs = threads.require(_this.config.root);
      } catch (err) {
        _this.config.logger.error(err);
      }
    } //
    // validate jobs
    //


    if (!Array.isArray(_this.config.jobs)) throw new Error('Jobs must be an Array'); // provide human-friendly errors for complex configurations

    var errors = [];
    /*
    jobs = [
      'name',
      { name: 'boot' },
      { name: 'timeout', timeout: ms('3s') },
      { name: 'cron', cron: '* * * * *' },
      { name: 'cron with timeout', timeout: '3s', cron: '* * * * *' },
      { name: 'interval', interval: ms('4s') }
      { name: 'interval', path: '/some/path/to/script.js', interval: ms('4s') },
      { name: 'timeout', timeout: 'three minutes' },
      { name: 'interval', interval: 'one minute' },
      { name: 'timeout', timeout: '3s' },
      { name: 'interval', interval: '30d' },
      { name: 'schedule object', interval: { schedules: [] } }
    ]
    */

    for (var i = 0; i < _this.config.jobs.length; i++) {
      try {
        var names = getJobNames(_this.config.jobs, i);
        validateJob(_this.config.jobs[i], i, names, _this.config);
        _this.config.jobs[i] = buildJob(_this.config.jobs[i], _this.config);
      } catch (err) {
        errors.push(err);
      }
    } // if there were any errors then throw them


    if (errors.length > 0) throw combineErrors(errors);
    debug('this.config.jobs', _this.config.jobs);
    return _this;
  }

  (0, _createClass2.default)(Bree, [{
    key: "getWorkerMetadata",
    value: function getWorkerMetadata(name) {
      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var job = this.config.jobs.find(function (j) {
        return j.name === name;
      });
      if (!job) throw new Error("Job \"".concat(name, "\" does not exist"));
      if (!this.config.outputWorkerMetadata && !job.outputWorkerMetadata) return meta && (typeof meta.err !== 'undefined' || typeof meta.message !== 'undefined') ? meta : undefined;
      return this.workers[name] ? _objectSpread(_objectSpread({}, meta), {}, {
        worker: {
          isMainThread: this.workers[name].isMainThread,
          resourceLimits: this.workers[name].resourceLimits,
          threadId: this.workers[name].threadId
        }
      }) : meta;
    }
  }, {
    key: "run",
    value: function run(name) {
      var _this2 = this;

      debug('run', name);

      if (name) {
        this.config.logger.info(new Date());
        var job = this.config.jobs.find(function (j) {
          return j.name === name;
        });
        if (!job) throw new Error("Job \"".concat(name, "\" does not exist"));
        if (this.workers[name]) return this.config.logger.warn(new Error("Job \"".concat(name, "\" is already running")), this.getWorkerMetadata(name));
        debug('starting worker', name);

        var object = _objectSpread(_objectSpread(_objectSpread({}, this.config.worker ? this.config.worker : {}), job.worker ? job.worker : {}), {}, {
          workerData: _objectSpread(_objectSpread({
            job: job
          }, this.config.worker && this.config.worker.workerData ? this.config.worker.workerData : {}), job.worker && job.worker.workerData ? job.worker.workerData : {})
        });

        this.workers[name] = new threads.Worker(job.path, object);
        this.emit('worker created', name);
        debug('worker started', name); // if we specified a value for `closeWorkerAfterMs`
        // then we need to terminate it after that execution time

        var closeWorkerAfterMs = Number.isFinite(job.closeWorkerAfterMs) ? job.closeWorkerAfterMs : this.config.closeWorkerAfterMs;

        if (Number.isFinite(closeWorkerAfterMs) && closeWorkerAfterMs > 0) {
          debug('worker has close set', name, closeWorkerAfterMs);
          this.closeWorkerAfterMs[name] = setTimeout(function () {
            if (_this2.workers[name]) {
              _this2.workers[name].terminate();
            }
          }, closeWorkerAfterMs);
        }

        var prefix = "Worker for job \"".concat(name, "\"");
        this.workers[name].on('online', function () {
          _this2.config.logger.info("".concat(prefix, " online"), _this2.getWorkerMetadata(name));
        });
        this.workers[name].on('message', function (message) {
          if (message === 'done') {
            _this2.config.logger.info("".concat(prefix, " signaled completion"), _this2.getWorkerMetadata(name));

            _this2.workers[name].removeAllListeners('message');

            _this2.workers[name].removeAllListeners('exit');

            _this2.workers[name].terminate();

            delete _this2.workers[name];
            return;
          }

          _this2.config.logger.info("".concat(prefix, " sent a message"), _this2.getWorkerMetadata(name, {
            message: message
          }));
        }); // NOTE: you cannot catch messageerror since it is a Node internal
        //       (if anyone has any idea how to catch this in tests let us know)

        /* istanbul ignore next */

        this.workers[name].on('messageerror', function (err) {
          if (_this2.config.errorHandler) {
            _this2.config.errorHandler(err, _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name, {
              err: err
            })));
          } else {
            _this2.config.logger.error("".concat(prefix, " had a message error"), _this2.getWorkerMetadata(name, {
              err: err
            }));
          }
        });
        this.workers[name].on('error', function (err) {
          if (_this2.config.errorHandler) {
            _this2.config.errorHandler(err, _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name, {
              err: err
            })));
          } else {
            _this2.config.logger.error("".concat(prefix, " had an error"), _this2.getWorkerMetadata(name, {
              err: err
            }));
          }
        });
        this.workers[name].on('exit', function (code) {
          var level = code === 0 ? 'info' : 'error';

          if (level === 'error' && _this2.config.errorHandler) {
            _this2.config.errorHandler(new Error("".concat(prefix, " exited with code ").concat(code)), _objectSpread({
              name: name
            }, _this2.getWorkerMetadata(name)));
          } else {
            _this2.config.logger[level]("".concat(prefix, " exited with code ").concat(code), _this2.getWorkerMetadata(name));
          }

          delete _this2.workers[name];

          _this2.emit('worker deleted', name);
        });
        return;
      }

      var _iterator = _createForOfIteratorHelper(this.config.jobs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _job = _step.value;
          this.run(_job.name);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "start",
    value: function start(name) {
      var _this3 = this;

      debug('start', name);

      if (name) {
        var job = this.config.jobs.find(function (j) {
          return j.name === name;
        });
        if (!job) throw new Error("Job ".concat(name, " does not exist"));
        if (this.timeouts[name] || this.intervals[name]) return this.config.logger.warn(new Error("Job \"".concat(name, "\" is already started")));
        debug('job', job); // check for date and if it is in the past then don't run it

        if (job.date instanceof Date) {
          debug('job date', job);

          if (job.date.getTime() < Date.now()) {
            debug('job date was in the past');
            return;
          }

          this.timeouts[name] = setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            }
          }, job.date.getTime() - Date.now());
          return;
        } // this is only complex because both timeout and interval can be a schedule


        if (this.isSchedule(job.timeout)) {
          debug('job timeout is schedule', job);
          this.timeouts[name] = later.setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            }
          }, job.timeout);
          return;
        }

        if (Number.isFinite(job.timeout)) {
          debug('job timeout is finite', job);
          this.timeouts[name] = setTimeout(function () {
            _this3.run(name);

            if (_this3.isSchedule(job.interval)) {
              debug('job.interval is schedule', job);
              _this3.intervals[name] = later.setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            } else if (Number.isFinite(job.interval) && job.interval > 0) {
              debug('job.interval is finite', job.interval);
              _this3.intervals[name] = setInterval(function () {
                return _this3.run(name);
              }, job.interval);
            }
          }, job.timeout);
        } else if (this.isSchedule(job.interval)) {
          debug('job.interval is schedule', job);
          this.intervals[name] = later.setInterval(function () {
            return _this3.run(name);
          }, job.interval);
        } else if (Number.isFinite(job.interval) && job.interval > 0) {
          debug('job.interval is finite', job);
          this.intervals[name] = setInterval(function () {
            return _this3.run(name);
          }, job.interval);
        }

        return;
      }

      var _iterator2 = _createForOfIteratorHelper(this.config.jobs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _job2 = _step2.value;
          this.start(_job2.name);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "stop",
    value: function () {
      var _stop = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {
        var _this4 = this;

        var _iterator3, _step3, job;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!name) {
                  _context.next = 6;
                  break;
                }

                if (this.timeouts[name]) {
                  if ((0, _typeof2.default)(this.timeouts[name]) === 'object' && typeof this.timeouts[name].clear === 'function') this.timeouts[name].clear();
                  delete this.timeouts[name];
                }

                if (this.intervals[name]) {
                  if ((0, _typeof2.default)(this.intervals[name]) === 'object' && typeof this.intervals[name].clear === 'function') this.intervals[name].clear();
                  delete this.intervals[name];
                }

                if (this.workers[name]) {
                  this.workers[name].once('message', function (message) {
                    if (message === 'cancelled') {
                      _this4.config.logger.info("Gracefully cancelled worker for job \"".concat(name, "\""), _this4.getWorkerMetadata(name));

                      _this4.workers[name].terminate();
                    }
                  });
                  this.workers[name].postMessage('cancel');
                }

                if (this.closeWorkerAfterMs[name]) {
                  if ((0, _typeof2.default)(this.closeWorkerAfterMs[name]) === 'object' && typeof this.closeWorkerAfterMs[name].clear === 'function') this.closeWorkerAfterMs[name].clear();
                  delete this.closeWorkerAfterMs[name];
                }

                return _context.abrupt("return", pWaitFor(function () {
                  return _this4.workers[name] === undefined;
                }));

              case 6:
                _iterator3 = _createForOfIteratorHelper(this.config.jobs);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    job = _step3.value;
                    this.stop(job.name);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                return _context.abrupt("return", pWaitFor(function () {
                  return Object.keys(_this4.workers).length === 0;
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function stop(_x) {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }, {
    key: "add",
    value: function add(jobs) {
      //
      // make sure jobs is an array
      //
      if (!Array.isArray(jobs)) jobs = [jobs];
      var errors = [];

      var _iterator4 = _createForOfIteratorHelper(jobs.entries()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
              i = _step4$value[0],
              job_ = _step4$value[1];

          try {
            var names = [].concat((0, _toConsumableArray2.default)(getJobNames(jobs, i)), (0, _toConsumableArray2.default)(getJobNames(this.config.jobs)));
            validateJob(job_, i, names, this.config);
            var job = buildJob(job_, this.config);
            this.config.jobs.push(job);
          } catch (err) {
            errors.push(err);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      debug('jobs added', this.config.jobs); // if there were any errors then throw them

      if (errors.length > 0) throw combineErrors(errors);
    }
  }, {
    key: "remove",
    value: function remove(name) {
      var job = this.config.jobs.find(function (j) {
        return j.name === name;
      });
      if (!job) throw new Error("Job \"".concat(name, "\" does not exist"));
      this.config.jobs = this.config.jobs.filter(function (j) {
        return j.name !== name;
      }); // make sure it also closes any open workers

      this.stop(name);
    }
  }]);
  return Bree;
}(EventEmitter); // expose bthreads (useful for tests)
// https://github.com/chjj/bthreads#api


Bree.threads = {
  backend: threads.backend,
  browser: threads.browser,
  location: threads.location,
  filename: threads.filename,
  dirname: threads.dirname,
  require: threads.require,
  resolve: threads.resolve,
  exit: threads.exit,
  cores: threads.cores
};
module.exports = Bree;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiZnMiLCJyZXNvbHZlIiwicFdhaXRGb3IiLCJjb21iaW5lRXJyb3JzIiwiZGVidWciLCJpc1NBTkIiLCJpc1ZhbGlkUGF0aCIsImxhdGVyIiwidGhyZWFkcyIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImlzU2NoZWR1bGUiLCJnZXROYW1lIiwiZ2V0SHVtYW5Ub01zIiwicGFyc2VWYWx1ZSIsImdldEpvYk5hbWVzIiwiYnVpbGRKb2IiLCJ2YWxpZGF0ZUpvYiIsIkJ1ZmZlciIsIkJyZWUiLCJjb25maWciLCJsb2dnZXIiLCJjb25zb2xlIiwicm9vdCIsImJyb3dzZXIiLCJ0aW1lb3V0IiwiaW50ZXJ2YWwiLCJqb2JzIiwiaGFzU2Vjb25kcyIsImNyb25WYWxpZGF0ZSIsImNsb3NlV29ya2VyQWZ0ZXJNcyIsImRlZmF1bHRFeHRlbnNpb24iLCJ3b3JrZXIiLCJlcnJvckhhbmRsZXIiLCJvdXRwdXRXb3JrZXJNZXRhZGF0YSIsInByZXNldCIsIm92ZXJyaWRlIiwidXNlU2Vjb25kcyIsIndvcmtlcnMiLCJ0aW1lb3V0cyIsImludGVydmFscyIsImdldFdvcmtlck1ldGFkYXRhIiwiYmluZCIsInJ1biIsInN0YXJ0Iiwic3RvcCIsImFkZCIsInJlbW92ZSIsInN0YXRzIiwic3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsIkVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZXJyIiwiZXJyb3IiLCJlcnJvcnMiLCJpIiwibmFtZXMiLCJwdXNoIiwibmFtZSIsIm1ldGEiLCJqb2IiLCJmaW5kIiwiaiIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJpc01haW5UaHJlYWQiLCJyZXNvdXJjZUxpbWl0cyIsInRocmVhZElkIiwiaW5mbyIsIkRhdGUiLCJ3YXJuIiwib2JqZWN0Iiwid29ya2VyRGF0YSIsIldvcmtlciIsInBhdGgiLCJlbWl0IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ0ZXJtaW5hdGUiLCJwcmVmaXgiLCJvbiIsInJlbW92ZUFsbExpc3RlbmVycyIsImNvZGUiLCJsZXZlbCIsImRhdGUiLCJnZXRUaW1lIiwibm93IiwiY2xlYXIiLCJvbmNlIiwicG9zdE1lc3NhZ2UiLCJPYmplY3QiLCJrZXlzIiwiZW50cmllcyIsImpvYl8iLCJmaWx0ZXIiLCJiYWNrZW5kIiwibG9jYXRpb24iLCJmaWxlbmFtZSIsImRpcm5hbWUiLCJleGl0IiwiY29yZXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFNQSxZQUFZLEdBQUdDLE9BQU8sQ0FBQyxRQUFELENBQTVCOztBQUNBLElBQU1DLEVBQUUsR0FBR0QsT0FBTyxDQUFDLElBQUQsQ0FBbEI7O2VBQ29CQSxPQUFPLENBQUMsTUFBRCxDO0lBQW5CRSxPLFlBQUFBLE87O0FBQ1IsSUFBTUMsUUFBUSxHQUFHSCxPQUFPLENBQUMsWUFBRCxDQUF4Qjs7QUFDQSxJQUFNSSxhQUFhLEdBQUdKLE9BQU8sQ0FBQyxnQkFBRCxDQUE3Qjs7QUFDQSxJQUFNSyxLQUFLLEdBQUdMLE9BQU8sQ0FBQyxPQUFELENBQVAsQ0FBaUIsTUFBakIsQ0FBZDs7QUFDQSxJQUFNTSxNQUFNLEdBQUdOLE9BQU8sQ0FBQyx5QkFBRCxDQUF0Qjs7QUFDQSxJQUFNTyxXQUFXLEdBQUdQLE9BQU8sQ0FBQyxlQUFELENBQTNCOztBQUNBLElBQU1RLEtBQUssR0FBR1IsT0FBTyxDQUFDLGVBQUQsQ0FBckI7O0FBQ0EsSUFBTVMsT0FBTyxHQUFHVCxPQUFPLENBQUMsVUFBRCxDQUF2Qjs7Z0JBQ29DQSxPQUFPLENBQUMsYUFBRCxDO0lBQW5DVSxVLGFBQUFBLFU7SUFBWUMsVyxhQUFBQSxXOztnQkFRaEJYLE9BQU8sQ0FBQyxhQUFELEM7SUFMVFksVSxhQUFBQSxVO0lBQ0FDLE8sYUFBQUEsTztJQUNBQyxZLGFBQUFBLFk7SUFDQUMsVSxhQUFBQSxV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S3pDLE1BQUwsQ0FBWU8sSUFBWixHQUFtQixLQUFLUCxNQUFMLENBQVlPLElBQVosQ0FBaUJzRSxNQUFqQixDQUF3QixVQUFDaEMsQ0FBRDtBQUFBLGVBQU9BLENBQUMsQ0FBQ0osSUFBRixLQUFXQSxJQUFsQjtBQUFBLE9BQXhCLENBQW5CLENBSlcsQ0FNWDs7QUFDQSxXQUFLaEIsSUFBTCxDQUFVZ0IsSUFBVjtBQUNEOzs7RUEzZmdCL0QsWSxHQThmbkI7QUFDQTs7O0FBQ0FxQixJQUFJLENBQUNYLE9BQUwsR0FBZTtBQUNiMEYsRUFBQUEsT0FBTyxFQUFFMUYsT0FBTyxDQUFDMEYsT0FESjtBQUViMUUsRUFBQUEsT0FBTyxFQUFFaEIsT0FBTyxDQUFDZ0IsT0FGSjtBQUdiMkUsRUFBQUEsUUFBUSxFQUFFM0YsT0FBTyxDQUFDMkYsUUFITDtBQUliQyxFQUFBQSxRQUFRLEVBQUU1RixPQUFPLENBQUM0RixRQUpMO0FBS2JDLEVBQUFBLE9BQU8sRUFBRTdGLE9BQU8sQ0FBQzZGLE9BTEo7QUFNYnRHLEVBQUFBLE9BQU8sRUFBRVMsT0FBTyxDQUFDVCxPQU5KO0FBT2JFLEVBQUFBLE9BQU8sRUFBRU8sT0FBTyxDQUFDUCxPQVBKO0FBUWJxRyxFQUFBQSxJQUFJLEVBQUU5RixPQUFPLENBQUM4RixJQVJEO0FBU2JDLEVBQUFBLEtBQUssRUFBRS9GLE9BQU8sQ0FBQytGO0FBVEYsQ0FBZjtBQVlBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJ0RixJQUFqQiIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwV2FpdEZvciA9IHJlcXVpcmUoJ3Atd2FpdC1mb3InKTtcbmNvbnN0IGNvbWJpbmVFcnJvcnMgPSByZXF1aXJlKCdjb21iaW5lLWVycm9ycycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdicmVlJyk7XG5jb25zdCBpc1NBTkIgPSByZXF1aXJlKCdpcy1zdHJpbmctYW5kLW5vdC1ibGFuaycpO1xuY29uc3QgaXNWYWxpZFBhdGggPSByZXF1aXJlKCdpcy12YWxpZC1wYXRoJyk7XG5jb25zdCBsYXRlciA9IHJlcXVpcmUoJ0BicmVlanMvbGF0ZXInKTtcbmNvbnN0IHRocmVhZHMgPSByZXF1aXJlKCdidGhyZWFkcycpO1xuY29uc3QgeyBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbCB9ID0gcmVxdWlyZSgnc2FmZS10aW1lcnMnKTtcblxuY29uc3Qge1xuICBpc1NjaGVkdWxlLFxuICBnZXROYW1lLFxuICBnZXRIdW1hblRvTXMsXG4gIHBhcnNlVmFsdWUsXG4gIGdldEpvYk5hbWVzXG59ID0gcmVxdWlyZSgnLi9qb2ItdXRpbHMnKTtcbmNvbnN0IGJ1aWxkSm9iID0gcmVxdWlyZSgnLi9qb2ItYnVpbGRlcicpO1xuY29uc3QgdmFsaWRhdGVKb2IgPSByZXF1aXJlKCcuL2pvYi12YWxpZGF0b3InKTtcblxuLy8gYnRocmVhZHMgcmVxdWlyZXMgdXMgdG8gZG8gdGhpcyBmb3Igd2ViIHdvcmtlcnMgKHNlZSBidGhyZWFkcyBkb2NzIGZvciBpbnNpZ2h0KVxudGhyZWFkcy5CdWZmZXIgPSBCdWZmZXI7XG5cbi8vIGluc3RlYWQgb2YgYHRocmVhZHMuYnJvd3NlcmAgY2hlY2tzIGJlbG93LCB3ZSBwcmV2aW91c2x5IHVzZWQgdGhpcyBib29sZWFuXG4vLyBjb25zdCBoYXNGc1N0YXRTeW5jID0gdHlwZW9mIGZzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZnMuc3RhdFN5bmMgPT09ICdmdW5jdGlvbic7XG5cbmNsYXNzIEJyZWUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLy8gd2UgcmVjb21tZW5kIHVzaW5nIENhYmluIGZvciBsb2dnaW5nXG4gICAgICAvLyA8aHR0cHM6Ly9jYWJpbmpzLmNvbT5cbiAgICAgIGxvZ2dlcjogY29uc29sZSxcbiAgICAgIC8vIHNldCB0aGlzIHRvIGBmYWxzZWAgdG8gcHJldmVudCByZXF1aXJpbmcgYSByb290IGRpcmVjdG9yeSBvZiBqb2JzXG4gICAgICAvLyAoZS5nLiBpZiB5b3VyIGpvYnMgYXJlIG5vdCBhbGwgaW4gb25lIGRpcmVjdG9yeSlcbiAgICAgIHJvb3Q6IHRocmVhZHMuYnJvd3NlclxuICAgICAgICA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhyZWFkcy5yZXNvbHZlKCdqb2JzJylcbiAgICAgICAgOiByZXNvbHZlKCdqb2JzJyksXG4gICAgICAvLyBkZWZhdWx0IHRpbWVvdXQgZm9yIGpvYnNcbiAgICAgIC8vIChzZXQgdGhpcyB0byBgZmFsc2VgIGlmIHlvdSBkbyBub3Qgd2lzaCBmb3IgYSBkZWZhdWx0IHRpbWVvdXQgdG8gYmUgc2V0KVxuICAgICAgdGltZW91dDogMCxcbiAgICAgIC8vIGRlZmF1bHQgaW50ZXJ2YWwgZm9yIGpvYnNcbiAgICAgIC8vIChzZXQgdGhpcyB0byBgMGAgZm9yIG5vIGludGVydmFsLCBhbmQgPiAwIGZvciBhIGRlZmF1bHQgaW50ZXJ2YWwgdG8gYmUgc2V0KVxuICAgICAgaW50ZXJ2YWw6IDAsXG4gICAgICAvLyB0aGlzIGlzIGFuIEFycmF5IG9mIHlvdXIgam9iIGRlZmluaXRpb25zIChzZWUgUkVBRE1FIGZvciBleGFtcGxlcylcbiAgICAgIGpvYnM6IFtdLFxuICAgICAgLy8gPGh0dHBzOi8vYnJlZWpzLmdpdGh1Yi5pby9sYXRlci9wYXJzZXJzLmh0bWwjY3Jvbj5cbiAgICAgIC8vIChjYW4gYmUgb3ZlcnJpZGRlbiBvbiBhIGpvYiBiYXNpcyB3aXRoIHNhbWUgcHJvcCBuYW1lKVxuICAgICAgaGFzU2Vjb25kczogZmFsc2UsXG4gICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL0FpcmZvb294L2Nyb24tdmFsaWRhdGU+XG4gICAgICBjcm9uVmFsaWRhdGU6IHt9LFxuICAgICAgLy8gaWYgeW91IHNldCBhIHZhbHVlID4gMCBoZXJlLCB0aGVuIGl0IHdpbGwgdGVybWluYXRlIHdvcmtlcnMgYWZ0ZXIgdGhpcyB0aW1lIChtcylcbiAgICAgIGNsb3NlV29ya2VyQWZ0ZXJNczogMCxcbiAgICAgIC8vIGNvdWxkIGFsc28gYmUgbWpzIGlmIGRlc2lyZWRcbiAgICAgIC8vICh0aGlzIGlzIHRoZSBkZWZhdWx0IGV4dGVuc2lvbiBpZiB5b3UganVzdCBzcGVjaWZ5IGEgam9iJ3MgbmFtZSB3aXRob3V0IFwiLmpzXCIgb3IgXCIubWpzXCIpXG4gICAgICBkZWZhdWx0RXh0ZW5zaW9uOiAnanMnLFxuICAgICAgLy8gZGVmYXVsdCB3b3JrZXIgb3B0aW9ucyB0byBwYXNzIHRvIH5gbmV3IFdvcmtlcmB+IGBuZXcgdGhyZWFkcy5Xb3JrZXJgXG4gICAgICAvLyAoY2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXIgam9iIGJhc2lzKVxuICAgICAgLy8gPGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvd29ya2VyX3RocmVhZHMuaHRtbCN3b3JrZXJfdGhyZWFkc19uZXdfd29ya2VyX2ZpbGVuYW1lX29wdGlvbnM+XG4gICAgICB3b3JrZXI6IHt9LFxuICAgICAgLy8gY3VzdG9tIGhhbmRsZXIgdG8gZXhlY3V0ZSB3aGVuIGVycm9yIGV2ZW50cyBhcmUgZW1taXRlZCBieSB0aGUgd29ya2VycyBvciB3aGVuIHRoZXkgZXhpdFxuICAgICAgLy8gd2l0aCBub24temVybyBjb2RlXG4gICAgICAvLyBwYXNzIGluIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBmb2xsb3dpbmcgc2lnbmF0dXJlOiBgKGVycm9yLCB3b3JrZXJNZXRhZGF0YSkgPT4geyAvLyBjdXN0b20gaGFuZGxpbmcgaGVyZSB9YFxuICAgICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuICAgICAgLy9cbiAgICAgIC8vIGlmIHlvdSBzZXQgdGhpcyB0byBgdHJ1ZWAsIHRoZW4gYSBzZWNvbmQgYXJnIGlzIHBhc3NlZCB0byBsb2cgb3V0cHV0XG4gICAgICAvLyBhbmQgaXQgd2lsbCBiZSBhbiBPYmplY3Qgd2l0aCBgeyB3b3JrZXI6IE9iamVjdCB9YCBzZXQsIGZvciBleGFtcGxlOlxuICAgICAgLy8gKHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBhdCA8aHR0cHM6Ly9ub2RlanMub3JnL2FwaS93b3JrZXJfdGhyZWFkcy5odG1sPiBmb3IgbW9yZSBpbnNpZ2h0KVxuICAgICAgLy9cbiAgICAgIC8vIGxvZ2dlci5pbmZvKCcuLi4nLCB7XG4gICAgICAvLyAgIHdvcmtlcjoge1xuICAgICAgLy8gICAgIGlzTWFpblRocmVhZDogQm9vbGVhblxuICAgICAgLy8gICAgIHJlc291cmNlTGltaXRzOiBPYmplY3QsXG4gICAgICAvLyAgICAgdGhyZWFkSWQ6IFN0cmluZ1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9KTtcbiAgICAgIC8vXG4gICAgICBvdXRwdXRXb3JrZXJNZXRhZGF0YTogZmFsc2UsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBpZiBgaGFzU2Vjb25kc2AgaXMgYHRydWVgIHRoZW4gZW5zdXJlIHRoYXRcbiAgICAvLyBgY3JvblZhbGlkYXRlYCBvYmplY3QgaGFzIGBvdmVycmlkZWAgb2JqZWN0IHdpdGggYHVzZVNlY29uZHNgIHNldCB0byBgdHJ1ZWBcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2JyZWVqcy9icmVlL2lzc3Vlcy83PlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY29uZmlnLmhhc1NlY29uZHMpXG4gICAgICB0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuY29uZmlnLmNyb25WYWxpZGF0ZSxcbiAgICAgICAgcHJlc2V0OlxuICAgICAgICAgIHRoaXMuY29uZmlnLmNyb25WYWxpZGF0ZSAmJiB0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUucHJlc2V0XG4gICAgICAgICAgICA/IHRoaXMuY29uZmlnLmNyb25WYWxpZGF0ZS5wcmVzZXRcbiAgICAgICAgICAgIDogJ2RlZmF1bHQnLFxuICAgICAgICBvdmVycmlkZToge1xuICAgICAgICAgIC4uLih0aGlzLmNvbmZpZy5jcm9uVmFsaWRhdGUgJiYgdGhpcy5jb25maWcuY3JvblZhbGlkYXRlLm92ZXJyaWRlXG4gICAgICAgICAgICA/IHRoaXMuY29uZmlnLmNyb25WYWxpZGF0ZS5vdmVycmlkZVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgdXNlU2Vjb25kczogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVidWcoJ2NvbmZpZycsIHRoaXMuY29uZmlnKTtcblxuICAgIHRoaXMuY2xvc2VXb3JrZXJBZnRlck1zID0ge307XG4gICAgdGhpcy53b3JrZXJzID0ge307XG4gICAgdGhpcy50aW1lb3V0cyA9IHt9O1xuICAgIHRoaXMuaW50ZXJ2YWxzID0ge307XG5cbiAgICB0aGlzLmlzU2NoZWR1bGUgPSBpc1NjaGVkdWxlO1xuICAgIHRoaXMuZ2V0V29ya2VyTWV0YWRhdGEgPSB0aGlzLmdldFdvcmtlck1ldGFkYXRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5ydW4gPSB0aGlzLnJ1bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wID0gdGhpcy5zdG9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGQgPSB0aGlzLmFkZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlID0gdGhpcy5yZW1vdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudmFsaWRhdGVKb2IgPSB2YWxpZGF0ZUpvYjtcbiAgICB0aGlzLmdldE5hbWUgPSBnZXROYW1lO1xuICAgIHRoaXMuZ2V0SHVtYW5Ub01zID0gZ2V0SHVtYW5Ub01zO1xuICAgIHRoaXMucGFyc2VWYWx1ZSA9IHBhcnNlVmFsdWU7XG5cbiAgICAvLyB2YWxpZGF0ZSByb290IChzeW5jIGNoZWNrKVxuICAgIGlmIChpc1NBTkIodGhpcy5jb25maWcucm9vdCkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoIXRocmVhZHMuYnJvd3NlciAmJiBpc1ZhbGlkUGF0aCh0aGlzLmNvbmZpZy5yb290KSkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHRoaXMuY29uZmlnLnJvb3QpO1xuICAgICAgICBpZiAoIXN0YXRzLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFJvb3QgZGlyZWN0b3J5IG9mICR7dGhpcy5jb25maWcucm9vdH0gZG9lcyBub3QgZXhpc3RgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSB0aW1lb3V0XG4gICAgdGhpcy5jb25maWcudGltZW91dCA9IHRoaXMucGFyc2VWYWx1ZSh0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICBkZWJ1ZygndGltZW91dCcsIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuXG4gICAgLy8gdmFsaWRhdGUgaW50ZXJ2YWxcbiAgICB0aGlzLmNvbmZpZy5pbnRlcnZhbCA9IHRoaXMucGFyc2VWYWx1ZSh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgZGVidWcoJ2ludGVydmFsJywgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuXG4gICAgLy9cbiAgICAvLyBpZiBgdGhpcy5jb25maWcuam9ic2AgaXMgYW4gZW1wdHkgYXJyYXlcbiAgICAvLyB0aGVuIHdlIHNob3VsZCB0cnkgdG8gbG9hZCBgam9icy9pbmRleC5qc2BcbiAgICAvL1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uZmlnLnJvb3QgJiZcbiAgICAgICghQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5qb2JzKSB8fCB0aGlzLmNvbmZpZy5qb2JzLmxlbmd0aCA9PT0gMClcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmpvYnMgPSB0aHJlYWRzLnJlcXVpcmUodGhpcy5jb25maWcucm9vdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyB2YWxpZGF0ZSBqb2JzXG4gICAgLy9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb25maWcuam9icykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pvYnMgbXVzdCBiZSBhbiBBcnJheScpO1xuXG4gICAgLy8gcHJvdmlkZSBodW1hbi1mcmllbmRseSBlcnJvcnMgZm9yIGNvbXBsZXggY29uZmlndXJhdGlvbnNcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIC8qXG4gICAgam9icyA9IFtcbiAgICAgICduYW1lJyxcbiAgICAgIHsgbmFtZTogJ2Jvb3QnIH0sXG4gICAgICB7IG5hbWU6ICd0aW1lb3V0JywgdGltZW91dDogbXMoJzNzJykgfSxcbiAgICAgIHsgbmFtZTogJ2Nyb24nLCBjcm9uOiAnKiAqICogKiAqJyB9LFxuICAgICAgeyBuYW1lOiAnY3JvbiB3aXRoIHRpbWVvdXQnLCB0aW1lb3V0OiAnM3MnLCBjcm9uOiAnKiAqICogKiAqJyB9LFxuICAgICAgeyBuYW1lOiAnaW50ZXJ2YWwnLCBpbnRlcnZhbDogbXMoJzRzJykgfVxuICAgICAgeyBuYW1lOiAnaW50ZXJ2YWwnLCBwYXRoOiAnL3NvbWUvcGF0aC90by9zY3JpcHQuanMnLCBpbnRlcnZhbDogbXMoJzRzJykgfSxcbiAgICAgIHsgbmFtZTogJ3RpbWVvdXQnLCB0aW1lb3V0OiAndGhyZWUgbWludXRlcycgfSxcbiAgICAgIHsgbmFtZTogJ2ludGVydmFsJywgaW50ZXJ2YWw6ICdvbmUgbWludXRlJyB9LFxuICAgICAgeyBuYW1lOiAndGltZW91dCcsIHRpbWVvdXQ6ICczcycgfSxcbiAgICAgIHsgbmFtZTogJ2ludGVydmFsJywgaW50ZXJ2YWw6ICczMGQnIH0sXG4gICAgICB7IG5hbWU6ICdzY2hlZHVsZSBvYmplY3QnLCBpbnRlcnZhbDogeyBzY2hlZHVsZXM6IFtdIH0gfVxuICAgIF1cbiAgICAqL1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5qb2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGdldEpvYk5hbWVzKHRoaXMuY29uZmlnLmpvYnMsIGkpO1xuXG4gICAgICAgIHZhbGlkYXRlSm9iKHRoaXMuY29uZmlnLmpvYnNbaV0sIGksIG5hbWVzLCB0aGlzLmNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jb25maWcuam9ic1tpXSA9IGJ1aWxkSm9iKHRoaXMuY29uZmlnLmpvYnNbaV0sIHRoaXMuY29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgYW55IGVycm9ycyB0aGVuIHRocm93IHRoZW1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IGNvbWJpbmVFcnJvcnMoZXJyb3JzKTtcblxuICAgIGRlYnVnKCd0aGlzLmNvbmZpZy5qb2JzJywgdGhpcy5jb25maWcuam9icyk7XG4gIH1cblxuICBnZXRXb3JrZXJNZXRhZGF0YShuYW1lLCBtZXRhID0ge30pIHtcbiAgICBjb25zdCBqb2IgPSB0aGlzLmNvbmZpZy5qb2JzLmZpbmQoKGopID0+IGoubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFqb2IpIHRocm93IG5ldyBFcnJvcihgSm9iIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5vdXRwdXRXb3JrZXJNZXRhZGF0YSAmJiAham9iLm91dHB1dFdvcmtlck1ldGFkYXRhKVxuICAgICAgcmV0dXJuIG1ldGEgJiZcbiAgICAgICAgKHR5cGVvZiBtZXRhLmVyciAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG1ldGEubWVzc2FnZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgID8gbWV0YVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy53b3JrZXJzW25hbWVdXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5tZXRhLFxuICAgICAgICAgIHdvcmtlcjoge1xuICAgICAgICAgICAgaXNNYWluVGhyZWFkOiB0aGlzLndvcmtlcnNbbmFtZV0uaXNNYWluVGhyZWFkLFxuICAgICAgICAgICAgcmVzb3VyY2VMaW1pdHM6IHRoaXMud29ya2Vyc1tuYW1lXS5yZXNvdXJjZUxpbWl0cyxcbiAgICAgICAgICAgIHRocmVhZElkOiB0aGlzLndvcmtlcnNbbmFtZV0udGhyZWFkSWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogbWV0YTtcbiAgfVxuXG4gIHJ1bihuYW1lKSB7XG4gICAgZGVidWcoJ3J1bicsIG5hbWUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuaW5mbyhuZXcgRGF0ZSgpKTtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuY29uZmlnLmpvYnMuZmluZCgoaikgPT4gai5uYW1lID09PSBuYW1lKTtcbiAgICAgIGlmICgham9iKSB0aHJvdyBuZXcgRXJyb3IoYEpvYiBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgaWYgKHRoaXMud29ya2Vyc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvZ2dlci53YXJuKFxuICAgICAgICAgIG5ldyBFcnJvcihgSm9iIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgcnVubmluZ2ApLFxuICAgICAgICAgIHRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSlcbiAgICAgICAgKTtcbiAgICAgIGRlYnVnKCdzdGFydGluZyB3b3JrZXInLCBuYW1lKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICAgLi4uKHRoaXMuY29uZmlnLndvcmtlciA/IHRoaXMuY29uZmlnLndvcmtlciA6IHt9KSxcbiAgICAgICAgLi4uKGpvYi53b3JrZXIgPyBqb2Iud29ya2VyIDoge30pLFxuICAgICAgICB3b3JrZXJEYXRhOiB7XG4gICAgICAgICAgam9iLFxuICAgICAgICAgIC4uLih0aGlzLmNvbmZpZy53b3JrZXIgJiYgdGhpcy5jb25maWcud29ya2VyLndvcmtlckRhdGFcbiAgICAgICAgICAgID8gdGhpcy5jb25maWcud29ya2VyLndvcmtlckRhdGFcbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLihqb2Iud29ya2VyICYmIGpvYi53b3JrZXIud29ya2VyRGF0YSA/IGpvYi53b3JrZXIud29ya2VyRGF0YSA6IHt9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdID0gbmV3IHRocmVhZHMuV29ya2VyKGpvYi5wYXRoLCBvYmplY3QpO1xuICAgICAgdGhpcy5lbWl0KCd3b3JrZXIgY3JlYXRlZCcsIG5hbWUpO1xuICAgICAgZGVidWcoJ3dvcmtlciBzdGFydGVkJywgbmFtZSk7XG5cbiAgICAgIC8vIGlmIHdlIHNwZWNpZmllZCBhIHZhbHVlIGZvciBgY2xvc2VXb3JrZXJBZnRlck1zYFxuICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHRlcm1pbmF0ZSBpdCBhZnRlciB0aGF0IGV4ZWN1dGlvbiB0aW1lXG4gICAgICBjb25zdCBjbG9zZVdvcmtlckFmdGVyTXMgPSBOdW1iZXIuaXNGaW5pdGUoam9iLmNsb3NlV29ya2VyQWZ0ZXJNcylcbiAgICAgICAgPyBqb2IuY2xvc2VXb3JrZXJBZnRlck1zXG4gICAgICAgIDogdGhpcy5jb25maWcuY2xvc2VXb3JrZXJBZnRlck1zO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjbG9zZVdvcmtlckFmdGVyTXMpICYmIGNsb3NlV29ya2VyQWZ0ZXJNcyA+IDApIHtcbiAgICAgICAgZGVidWcoJ3dvcmtlciBoYXMgY2xvc2Ugc2V0JywgbmFtZSwgY2xvc2VXb3JrZXJBZnRlck1zKTtcbiAgICAgICAgdGhpcy5jbG9zZVdvcmtlckFmdGVyTXNbbmFtZV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbbmFtZV0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjbG9zZVdvcmtlckFmdGVyTXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmVmaXggPSBgV29ya2VyIGZvciBqb2IgXCIke25hbWV9XCJgO1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdLm9uKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlci5pbmZvKFxuICAgICAgICAgIGAke3ByZWZpeH0gb25saW5lYCxcbiAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSAnZG9uZScpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIGAke3ByZWZpeH0gc2lnbmFsZWQgY29tcGxldGlvbmAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLndvcmtlcnNbbmFtZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdtZXNzYWdlJyk7XG4gICAgICAgICAgdGhpcy53b3JrZXJzW25hbWVdLnJlbW92ZUFsbExpc3RlbmVycygnZXhpdCcpO1xuICAgICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy53b3JrZXJzW25hbWVdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlci5pbmZvKFxuICAgICAgICAgIGAke3ByZWZpeH0gc2VudCBhIG1lc3NhZ2VgLFxuICAgICAgICAgIHRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSwgeyBtZXNzYWdlIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIC8vIE5PVEU6IHlvdSBjYW5ub3QgY2F0Y2ggbWVzc2FnZWVycm9yIHNpbmNlIGl0IGlzIGEgTm9kZSBpbnRlcm5hbFxuICAgICAgLy8gICAgICAgKGlmIGFueW9uZSBoYXMgYW55IGlkZWEgaG93IHRvIGNhdGNoIHRoaXMgaW4gdGVzdHMgbGV0IHVzIGtub3cpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhpcy53b3JrZXJzW25hbWVdLm9uKCdtZXNzYWdlZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5lcnJvckhhbmRsZXIoZXJyLCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgLi4udGhpcy5nZXRXb3JrZXJNZXRhZGF0YShuYW1lLCB7IGVyciB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgIGAke3ByZWZpeH0gaGFkIGEgbWVzc2FnZSBlcnJvcmAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUsIHsgZXJyIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnNbbmFtZV0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKGVyciwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSwgeyBlcnIgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICBgJHtwcmVmaXh9IGhhZCBhbiBlcnJvcmAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUsIHsgZXJyIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnNbbmFtZV0ub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGNvZGUgPT09IDAgPyAnaW5mbycgOiAnZXJyb3InO1xuICAgICAgICBpZiAobGV2ZWwgPT09ICdlcnJvcicgJiYgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZXJyb3JIYW5kbGVyKFxuICAgICAgICAgICAgbmV3IEVycm9yKGAke3ByZWZpeH0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIC4uLnRoaXMuZ2V0V29ya2VyTWV0YWRhdGEobmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlcltsZXZlbF0oXG4gICAgICAgICAgICBgJHtwcmVmaXh9IGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtlck1ldGFkYXRhKG5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLndvcmtlcnNbbmFtZV07XG4gICAgICAgIHRoaXMuZW1pdCgnd29ya2VyIGRlbGV0ZWQnLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXMuY29uZmlnLmpvYnMpIHtcbiAgICAgIHRoaXMucnVuKGpvYi5uYW1lKTtcbiAgICB9XG4gIH1cblxuICBzdGFydChuYW1lKSB7XG4gICAgZGVidWcoJ3N0YXJ0JywgbmFtZSk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuY29uZmlnLmpvYnMuZmluZCgoaikgPT4gai5uYW1lID09PSBuYW1lKTtcbiAgICAgIGlmICgham9iKSB0aHJvdyBuZXcgRXJyb3IoYEpvYiAke25hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICBpZiAodGhpcy50aW1lb3V0c1tuYW1lXSB8fCB0aGlzLmludGVydmFsc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvZ2dlci53YXJuKFxuICAgICAgICAgIG5ldyBFcnJvcihgSm9iIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgc3RhcnRlZGApXG4gICAgICAgICk7XG5cbiAgICAgIGRlYnVnKCdqb2InLCBqb2IpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgZGF0ZSBhbmQgaWYgaXQgaXMgaW4gdGhlIHBhc3QgdGhlbiBkb24ndCBydW4gaXRcbiAgICAgIGlmIChqb2IuZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgZGVidWcoJ2pvYiBkYXRlJywgam9iKTtcbiAgICAgICAgaWYgKGpvYi5kYXRlLmdldFRpbWUoKSA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICBkZWJ1Zygnam9iIGRhdGUgd2FzIGluIHRoZSBwYXN0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aW1lb3V0c1tuYW1lXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucnVuKG5hbWUpO1xuICAgICAgICAgIGlmICh0aGlzLmlzU2NoZWR1bGUoam9iLmludGVydmFsKSkge1xuICAgICAgICAgICAgZGVidWcoJ2pvYi5pbnRlcnZhbCBpcyBzY2hlZHVsZScsIGpvYik7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXSA9IGxhdGVyLnNldEludGVydmFsKFxuICAgICAgICAgICAgICAoKSA9PiB0aGlzLnJ1bihuYW1lKSxcbiAgICAgICAgICAgICAgam9iLmludGVydmFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGpvYi5pbnRlcnZhbCkgJiYgam9iLmludGVydmFsID4gMCkge1xuICAgICAgICAgICAgZGVidWcoJ2pvYi5pbnRlcnZhbCBpcyBmaW5pdGUnLCBqb2IpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy5ydW4obmFtZSksXG4gICAgICAgICAgICAgIGpvYi5pbnRlcnZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGpvYi5kYXRlLmdldFRpbWUoKSAtIERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgaXMgb25seSBjb21wbGV4IGJlY2F1c2UgYm90aCB0aW1lb3V0IGFuZCBpbnRlcnZhbCBjYW4gYmUgYSBzY2hlZHVsZVxuICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsZShqb2IudGltZW91dCkpIHtcbiAgICAgICAgZGVidWcoJ2pvYiB0aW1lb3V0IGlzIHNjaGVkdWxlJywgam9iKTtcbiAgICAgICAgdGhpcy50aW1lb3V0c1tuYW1lXSA9IGxhdGVyLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucnVuKG5hbWUpO1xuICAgICAgICAgIGlmICh0aGlzLmlzU2NoZWR1bGUoam9iLmludGVydmFsKSkge1xuICAgICAgICAgICAgZGVidWcoJ2pvYi5pbnRlcnZhbCBpcyBzY2hlZHVsZScsIGpvYik7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXSA9IGxhdGVyLnNldEludGVydmFsKFxuICAgICAgICAgICAgICAoKSA9PiB0aGlzLnJ1bihuYW1lKSxcbiAgICAgICAgICAgICAgam9iLmludGVydmFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGpvYi5pbnRlcnZhbCkgJiYgam9iLmludGVydmFsID4gMCkge1xuICAgICAgICAgICAgZGVidWcoJ2pvYi5pbnRlcnZhbCBpcyBmaW5pdGUnLCBqb2IpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy5ydW4obmFtZSksXG4gICAgICAgICAgICAgIGpvYi5pbnRlcnZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGpvYi50aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGpvYi50aW1lb3V0KSkge1xuICAgICAgICBkZWJ1Zygnam9iIHRpbWVvdXQgaXMgZmluaXRlJywgam9iKTtcbiAgICAgICAgdGhpcy50aW1lb3V0c1tuYW1lXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucnVuKG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNTY2hlZHVsZShqb2IuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIHNjaGVkdWxlJywgam9iKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdID0gbGF0ZXIuc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICgpID0+IHRoaXMucnVuKG5hbWUpLFxuICAgICAgICAgICAgICBqb2IuaW50ZXJ2YWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoam9iLmludGVydmFsKSAmJiBqb2IuaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIGZpbml0ZScsIGpvYi5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsc1tuYW1lXSA9IHNldEludGVydmFsKFxuICAgICAgICAgICAgICAoKSA9PiB0aGlzLnJ1bihuYW1lKSxcbiAgICAgICAgICAgICAgam9iLmludGVydmFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgam9iLnRpbWVvdXQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2NoZWR1bGUoam9iLmludGVydmFsKSkge1xuICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIHNjaGVkdWxlJywgam9iKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHNbbmFtZV0gPSBsYXRlci5zZXRJbnRlcnZhbChcbiAgICAgICAgICAoKSA9PiB0aGlzLnJ1bihuYW1lKSxcbiAgICAgICAgICBqb2IuaW50ZXJ2YWxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGpvYi5pbnRlcnZhbCkgJiYgam9iLmludGVydmFsID4gMCkge1xuICAgICAgICBkZWJ1Zygnam9iLmludGVydmFsIGlzIGZpbml0ZScsIGpvYik7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ydW4obmFtZSksIGpvYi5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGpvYiBvZiB0aGlzLmNvbmZpZy5qb2JzKSB7XG4gICAgICB0aGlzLnN0YXJ0KGpvYi5uYW1lKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgaWYgKHRoaXMudGltZW91dHNbbmFtZV0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0aGlzLnRpbWVvdXRzW25hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiB0aGlzLnRpbWVvdXRzW25hbWVdLmNsZWFyID09PSAnZnVuY3Rpb24nXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLnRpbWVvdXRzW25hbWVdLmNsZWFyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVvdXRzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbHNbbmFtZV0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0aGlzLmludGVydmFsc1tuYW1lXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB0eXBlb2YgdGhpcy5pbnRlcnZhbHNbbmFtZV0uY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW25hbWVdLmNsZWFyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmludGVydmFsc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud29ya2Vyc1tuYW1lXSkge1xuICAgICAgICB0aGlzLndvcmtlcnNbbmFtZV0ub25jZSgnbWVzc2FnZScsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UgPT09ICdjYW5jZWxsZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICAgICAgYEdyYWNlZnVsbHkgY2FuY2VsbGVkIHdvcmtlciBmb3Igam9iIFwiJHtuYW1lfVwiYCxcbiAgICAgICAgICAgICAgdGhpcy5nZXRXb3JrZXJNZXRhZGF0YShuYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2Vyc1tuYW1lXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlcnNbbmFtZV0ucG9zdE1lc3NhZ2UoJ2NhbmNlbCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZVdvcmtlckFmdGVyTXNbbmFtZV0pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB0eXBlb2YgdGhpcy5jbG9zZVdvcmtlckFmdGVyTXNbbmFtZV0uY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMuY2xvc2VXb3JrZXJBZnRlck1zW25hbWVdLmNsZWFyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsb3NlV29ya2VyQWZ0ZXJNc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBXYWl0Rm9yKCgpID0+IHRoaXMud29ya2Vyc1tuYW1lXSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGpvYiBvZiB0aGlzLmNvbmZpZy5qb2JzKSB7XG4gICAgICB0aGlzLnN0b3Aoam9iLm5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwV2FpdEZvcigoKSA9PiBPYmplY3Qua2V5cyh0aGlzLndvcmtlcnMpLmxlbmd0aCA9PT0gMCk7XG4gIH1cblxuICBhZGQoam9icykge1xuICAgIC8vXG4gICAgLy8gbWFrZSBzdXJlIGpvYnMgaXMgYW4gYXJyYXlcbiAgICAvL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShqb2JzKSkgam9icyA9IFtqb2JzXTtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbaSwgam9iX10gb2Ygam9icy5lbnRyaWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gW1xuICAgICAgICAgIC4uLmdldEpvYk5hbWVzKGpvYnMsIGkpLFxuICAgICAgICAgIC4uLmdldEpvYk5hbWVzKHRoaXMuY29uZmlnLmpvYnMpXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFsaWRhdGVKb2Ioam9iXywgaSwgbmFtZXMsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgY29uc3Qgam9iID0gYnVpbGRKb2Ioam9iXywgdGhpcy5jb25maWcpO1xuXG4gICAgICAgIHRoaXMuY29uZmlnLmpvYnMucHVzaChqb2IpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2pvYnMgYWRkZWQnLCB0aGlzLmNvbmZpZy5qb2JzKTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgYW55IGVycm9ycyB0aGVuIHRocm93IHRoZW1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IGNvbWJpbmVFcnJvcnMoZXJyb3JzKTtcbiAgfVxuXG4gIHJlbW92ZShuYW1lKSB7XG4gICAgY29uc3Qgam9iID0gdGhpcy5jb25maWcuam9icy5maW5kKChqKSA9PiBqLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICgham9iKSB0aHJvdyBuZXcgRXJyb3IoYEpvYiBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuXG4gICAgdGhpcy5jb25maWcuam9icyA9IHRoaXMuY29uZmlnLmpvYnMuZmlsdGVyKChqKSA9PiBqLm5hbWUgIT09IG5hbWUpO1xuXG4gICAgLy8gbWFrZSBzdXJlIGl0IGFsc28gY2xvc2VzIGFueSBvcGVuIHdvcmtlcnNcbiAgICB0aGlzLnN0b3AobmFtZSk7XG4gIH1cbn1cblxuLy8gZXhwb3NlIGJ0aHJlYWRzICh1c2VmdWwgZm9yIHRlc3RzKVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovYnRocmVhZHMjYXBpXG5CcmVlLnRocmVhZHMgPSB7XG4gIGJhY2tlbmQ6IHRocmVhZHMuYmFja2VuZCxcbiAgYnJvd3NlcjogdGhyZWFkcy5icm93c2VyLFxuICBsb2NhdGlvbjogdGhyZWFkcy5sb2NhdGlvbixcbiAgZmlsZW5hbWU6IHRocmVhZHMuZmlsZW5hbWUsXG4gIGRpcm5hbWU6IHRocmVhZHMuZGlybmFtZSxcbiAgcmVxdWlyZTogdGhyZWFkcy5yZXF1aXJlLFxuICByZXNvbHZlOiB0aHJlYWRzLnJlc29sdmUsXG4gIGV4aXQ6IHRocmVhZHMuZXhpdCxcbiAgY29yZXM6IHRocmVhZHMuY29yZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnJlZTtcbiJdfQ==