"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var yearCalculation_1 = require("../../../calculation/yearCalculation");
var constants_1 = require("../constants");
var constants_2 = require("../constants");
var constants_3 = require("../constants");
var pattern_1 = require("../../../utils/pattern");
var AbstractParserWithWordBoundary_1 = require("../../../common/parsers/AbstractParserWithWordBoundary");
var PATTERN = new RegExp('(?:on\\s*?)?' +
    ("(?:(" + pattern_1.matchAnyPattern(constants_1.WEEKDAY_DICTIONARY) + ")\\s*,?\\s*)?") +
    ("(" + constants_3.ORDINAL_NUMBER_PATTERN + ")") +
    '(?:\\s*' +
    '(?:to|\\-|\\â€“|until|through|till|\\s)\\s*' +
    ("(" + constants_3.ORDINAL_NUMBER_PATTERN + ")") +
    ')?' +
    '(?:-|/|\\s*(?:of)?\\s*)' +
    '(' + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + ')' +
    '(?:' +
    '(?:-|/|,?\\s*)' +
    ("(" + constants_2.YEAR_PATTERN + "(?![^\\s]\\d))") +
    ')?' +
    '(?=\\W|$)', 'i');
var WEEKDAY_GROUP = 1;
var DATE_GROUP = 2;
var DATE_TO_GROUP = 3;
var MONTH_NAME_GROUP = 4;
var YEAR_GROUP = 5;
var ENMonthNameLittleEndianParser = (function (_super) {
    __extends(ENMonthNameLittleEndianParser, _super);
    function ENMonthNameLittleEndianParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ENMonthNameLittleEndianParser.prototype.innerPattern = function () {
        return PATTERN;
    };
    ENMonthNameLittleEndianParser.prototype.innerExtract = function (context, match) {
        var result = context.createParsingResult(match.index, match[0]);
        var month = constants_1.MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];
        var day = constants_3.parseOrdinalNumberPattern(match[DATE_GROUP]);
        if (day > 31) {
            match.index = match.index + match[DATE_GROUP].length;
            return null;
        }
        result.start.assign('month', month);
        result.start.assign('day', day);
        if (match[WEEKDAY_GROUP]) {
            var weekday = constants_1.WEEKDAY_DICTIONARY[match[WEEKDAY_GROUP].toLowerCase()];
            result.start.assign('weekday', weekday);
        }
        if (match[YEAR_GROUP]) {
            var yearNumber = constants_2.parseYear(match[YEAR_GROUP]);
            result.start.assign('year', yearNumber);
        }
        else {
            var year = yearCalculation_1.findYearClosestToRef(context.refDate, day, month);
            result.start.imply('year', year);
        }
        if (match[DATE_TO_GROUP]) {
            var endDate = constants_3.parseOrdinalNumberPattern(match[DATE_TO_GROUP]);
            result.end = result.start.clone();
            result.end.assign('day', endDate);
        }
        return result;
    };
    return ENMonthNameLittleEndianParser;
}(AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking));
exports.default = ENMonthNameLittleEndianParser;
