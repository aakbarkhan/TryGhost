"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("../constants");
var yearCalculation_1 = require("../../../calculation/yearCalculation");
var pattern_1 = require("../../../utils/pattern");
var constants_2 = require("../constants");
var AbstractParserWithWordBoundary_1 = require("../../../common/parsers/AbstractParserWithWordBoundary");
var PATTERN = new RegExp("(" + pattern_1.matchAnyPattern(constants_1.MONTH_DICTIONARY) + ")" +
    '\\s*' +
    '(?:' +
    ("[,-]?\\s*(" + constants_2.YEAR_PATTERN + ")?") +
    ')?' +
    '(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)', 'i');
var MONTH_NAME_GROUP = 1;
var YEAR_GROUP = 2;
var ENMonthNameParser = (function (_super) {
    __extends(ENMonthNameParser, _super);
    function ENMonthNameParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ENMonthNameParser.prototype.innerPattern = function () { return PATTERN; };
    ENMonthNameParser.prototype.innerExtract = function (context, match) {
        if (match[0].length <= 3) {
            return null;
        }
        var components = context.createParsingComponents();
        components.imply('day', 1);
        var monthName = match[MONTH_NAME_GROUP];
        var month = constants_1.MONTH_DICTIONARY[monthName.toLowerCase()];
        components.assign('month', month);
        if (match[YEAR_GROUP]) {
            var year = constants_2.parseYear(match[YEAR_GROUP]);
            components.assign('year', year);
        }
        else {
            var year = yearCalculation_1.findYearClosestToRef(context.refDate, 1, month);
            components.imply('year', year);
        }
        return components;
    };
    return ENMonthNameParser;
}(AbstractParserWithWordBoundary_1.AbstractParserWithWordBoundaryChecking));
exports.default = ENMonthNameParser;
