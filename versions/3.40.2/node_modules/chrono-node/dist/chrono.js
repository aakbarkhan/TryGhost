"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParsingContext = exports.Chrono = void 0;
var results_1 = require("./results");
var en_1 = require("./locales/en");
var Chrono = (function () {
    function Chrono(configuration) {
        configuration = configuration || en_1.createCasualConfiguration();
        this.parsers = __spread(configuration.parsers);
        this.refiners = __spread(configuration.refiners);
    }
    Chrono.prototype.parseDate = function (text, refDate, opt) {
        var results = this.parse(text, refDate, opt);
        return (results.length > 0) ? results[0].start.date() : null;
    };
    Chrono.prototype.parse = function (text, refDate, opt) {
        var context = new ParsingContext(text, refDate || new Date(), opt || {});
        var results = [];
        this.parsers.forEach(function (parser) {
            var parsedResults = Chrono.executeParser(context, parser);
            results = results.concat(parsedResults);
        });
        results.sort(function (a, b) {
            return a.index - b.index;
        });
        this.refiners.forEach(function (refiner) {
            results = refiner.refine(context, results);
        });
        return results;
    };
    Chrono.prototype.clone = function () {
        return new Chrono({
            parsers: __spread(this.parsers),
            refiners: __spread(this.refiners)
        });
    };
    Chrono.executeParser = function (context, parser) {
        var results = [];
        var pattern = parser.pattern(context);
        var originalText = context.text;
        var remainingText = context.text;
        var match = pattern.exec(remainingText);
        var _loop_1 = function () {
            var index = match.index + originalText.length - remainingText.length;
            match.index = index;
            var result = parser.extract(context, match);
            if (!result) {
                remainingText = originalText.substring(match.index + 1);
                match = pattern.exec(remainingText);
                return "continue";
            }
            var parsedResult = null;
            if (result instanceof results_1.ParsingResult) {
                parsedResult = result;
            }
            else if (result instanceof results_1.ParsingComponents) {
                parsedResult = context.createParsingResult(match.index, match[0]);
                parsedResult.start = result;
            }
            else {
                parsedResult = context.createParsingResult(match.index, match[0], result);
            }
            context.debug(function () {
                return console.log(parser.constructor.name + " extracted result " + parsedResult);
            });
            results.push(parsedResult);
            remainingText = originalText.substring(index + parsedResult.text.length);
            match = pattern.exec(remainingText);
        };
        while (match) {
            _loop_1();
        }
        return results;
    };
    return Chrono;
}());
exports.Chrono = Chrono;
var ParsingContext = (function () {
    function ParsingContext(text, refDate, option) {
        this.text = text;
        this.refDate = refDate;
        this.option = option;
    }
    ParsingContext.prototype.createParsingComponents = function (components) {
        return new results_1.ParsingComponents(this.refDate, components);
    };
    ParsingContext.prototype.createParsingResult = function (index, textOrEndIndex, startComponents, endComponents) {
        var text = (typeof textOrEndIndex === 'string') ? textOrEndIndex :
            this.text.substring(index, textOrEndIndex);
        var start = startComponents ? this.createParsingComponents(startComponents) : null;
        var end = endComponents ? this.createParsingComponents(endComponents) : null;
        return new results_1.ParsingResult(this.refDate, index, text, start, end);
    };
    ParsingContext.prototype.debug = function (block) {
        if (this.option.debug) {
            if (this.option.debug instanceof Function) {
                this.option.debug(block);
            }
            else {
                var handler = this.option.debug;
                handler.debug(block);
            }
        }
    };
    return ParsingContext;
}());
exports.ParsingContext = ParsingContext;
